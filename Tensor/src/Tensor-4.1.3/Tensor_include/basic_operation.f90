#define minFuncName mini
#define maxFuncName maxi
#define sumFuncName sumi
#define traceFuncName tracei
#define normFuncName normi
#define norm2FuncName norm2i
#define product_dotFuncName product_doti
#define product_cdotFuncName product_cdoti
#define DATATYPE integer
#include "templet/basic_operation0.f90"
#undef minFuncName
#undef maxFuncName
#undef sumFuncName
#undef traceFuncName
#undef normFuncName
#undef norm2FuncName
#undef product_dotFuncName
#undef product_cdotFuncName
#undef DATATYPE

#define minFuncName mins
#define maxFuncName maxs
#define sumFuncName sums
#define traceFuncName traces
#define normFuncName norms
#define norm2FuncName norm2s
#define product_dotFuncName product_dots
#define product_cdotFuncName product_cdots
#define DATATYPE real*4
#include "templet/basic_operation0.f90"
#undef minFuncName
#undef maxFuncName
#undef sumFuncName
#undef traceFuncName
#undef normFuncName
#undef norm2FuncName
#undef product_dotFuncName
#undef product_cdotFuncName
#undef DATATYPE

#define minFuncName mind
#define maxFuncName maxd
#define sumFuncName sumd
#define traceFuncName traced
#define normFuncName normd
#define norm2FuncName norm2d
#define product_dotFuncName product_dotd
#define product_cdotFuncName product_cdotd
#define DATATYPE real*8
#include "templet/basic_operation0.f90"
#undef minFuncName
#undef maxFuncName
#undef sumFuncName
#undef traceFuncName
#undef normFuncName
#undef norm2FuncName
#undef product_dotFuncName
#undef product_cdotFuncName
#undef DATATYPE

#define minFuncName minc
#define maxFuncName maxc
#define sumFuncName sumc
#define traceFuncName tracec
#define normFuncName normc
#define norm2FuncName norm2c
#define product_dotFuncName product_dotc
#define product_cdotFuncName product_cdotc
#define DATATYPE complex*8
#include "templet/basic_operation0.f90"
#undef minFuncName
#undef maxFuncName
#undef sumFuncName
#undef traceFuncName
#undef normFuncName
#undef norm2FuncName
#undef product_dotFuncName
#undef product_cdotFuncName
#undef DATATYPE

#define minFuncName minz
#define maxFuncName maxz
#define sumFuncName sumz
#define traceFuncName tracez
#define normFuncName normz
#define norm2FuncName norm2z
#define product_dotFuncName product_dotz
#define product_cdotFuncName product_cdotz
#define DATATYPE complex*16
#include "templet/basic_operation0.f90"
#undef minFuncName
#undef maxFuncName
#undef sumFuncName
#undef traceFuncName
#undef normFuncName
#undef norm2FuncName
#undef product_dotFuncName
#undef product_cdotFuncName
#undef DATATYPE


#define minFuncName minT
#define maxFuncName maxT
#define sumFuncName sumT
#define traceFuncName traceT
#define normFuncName normT
#define norm2FuncName norm2T
#define product_dotFuncName product_dotT
#define product_cdotFuncName product_cdotT
#define DATATYPE type(Tensor)
#include "templet/basic_operation0.f90"
#undef minFuncName
#undef maxFuncName
#undef sumFuncName
#undef traceFuncName
#undef normFuncName
#undef norm2FuncName
#undef product_dotFuncName
#undef product_cdotFuncName
#undef DATATYPE


#define multiplyFuncName multiplyi
#define divideFuncName dividei
#define TplusNumSubroutineFuncName TplusNumSubroutinei
#define TminusNumSubroutineFuncName TminusNumSubroutinei
#define NumminusTSubroutineFuncName NumminusTSubroutinei
#define TplusNumFuncName TplusNumi
#define NumplusTFuncName NumplusTi
#define TMinusNumFuncName TMinusNumi
#define NumMinusTFuncName NumMinusTi
#define TmultiplyNumFuncName TmultiplyNumi
#define NumMultiplyTFuncName NumMultiplyTi
#define TdivideNumFuncName TdivideNumi
#define NumdivideTFuncName NumdivideTi
#define DATATYPENumber 1
#define DATATYPE integer
#define NTimeTTYPE 2
#include "templet/multip_divide_plus.f90"
#undef multiplyFuncName
#undef divideFuncName
#undef TplusNumSubroutineFuncName
#undef TminusNumSubroutineFuncName
#undef NumminusTSubroutineFuncName
#undef TplusNumFuncName
#undef NumplusTFuncName
#undef TMinusNumFuncName
#undef NumMinusTFuncName
#undef TmultiplyNumFuncName
#undef NumMultiplyTFuncName
#undef TdivideNumFuncName
#undef NumdivideTFuncName
#undef DATATYPENumber
#undef NTimeTTYPE
#undef DATATYPE


#define multiplyFuncName multiplys
#define divideFuncName divides
#define TplusNumSubroutineFuncName TplusNumSubroutines
#define TminusNumSubroutineFuncName TminusNumSubroutines
#define NumminusTSubroutineFuncName NumminusTSubroutines
#define TplusNumFuncName TplusNums
#define NumplusTFuncName NumplusTs
#define TMinusNumFuncName TMinusNums
#define NumMinusTFuncName NumMinusTs
#define TmultiplyNumFuncName TmultiplyNums
#define NumMultiplyTFuncName NumMultiplyTs
#define TdivideNumFuncName TdivideNums
#define NumdivideTFuncName NumdivideTs
#define DATATYPENumber 2
#define DATATYPE real*4
#define NTimeTTYPE 2
#include "templet/multip_divide_plus.f90"
#undef multiplyFuncName
#undef divideFuncName
#undef TplusNumSubroutineFuncName
#undef TminusNumSubroutineFuncName
#undef NumminusTSubroutineFuncName
#undef TplusNumFuncName
#undef NumplusTFuncName
#undef TMinusNumFuncName
#undef NumMinusTFuncName
#undef TmultiplyNumFuncName
#undef NumMultiplyTFuncName
#undef TdivideNumFuncName
#undef NumdivideTFuncName
#undef DATATYPENumber
#undef DATATYPE
#undef NTimeTTYPE

#define multiplyFuncName multiplyd
#define divideFuncName divided
#define TplusNumSubroutineFuncName TplusNumSubroutined
#define TminusNumSubroutineFuncName TminusNumSubroutined
#define NumminusTSubroutineFuncName NumminusTSubroutined
#define TplusNumFuncName TplusNumd
#define NumplusTFuncName NumplusTd
#define TMinusNumFuncName TMinusNumd
#define NumMinusTFuncName NumMinusTd
#define TmultiplyNumFuncName TmultiplyNumd
#define NumMultiplyTFuncName NumMultiplyTd
#define TdivideNumFuncName TdivideNumd
#define NumdivideTFuncName NumdivideTd
#define DATATYPENumber 3
#define DATATYPE real*8
#define NTimeTTYPE 3
#include "templet/multip_divide_plus.f90"
#undef multiplyFuncName
#undef divideFuncName
#undef TplusNumSubroutineFuncName
#undef TminusNumSubroutineFuncName
#undef NumminusTSubroutineFuncName
#undef TplusNumFuncName
#undef NumplusTFuncName
#undef TMinusNumFuncName
#undef NumMinusTFuncName
#undef TmultiplyNumFuncName
#undef NumMultiplyTFuncName
#undef TdivideNumFuncName
#undef NumdivideTFuncName
#undef DATATYPENumber
#undef DATATYPE
#undef NTimeTTYPE

#define multiplyFuncName multiplyc
#define divideFuncName dividec
#define TplusNumSubroutineFuncName TplusNumSubroutinec
#define TminusNumSubroutineFuncName TminusNumSubroutinec
#define NumminusTSubroutineFuncName NumminusTSubroutinec
#define TplusNumFuncName TplusNumc
#define NumplusTFuncName NumplusTc
#define TMinusNumFuncName TMinusNumc
#define NumMinusTFuncName NumMinusTc
#define TmultiplyNumFuncName TmultiplyNumc
#define NumMultiplyTFuncName NumMultiplyTc
#define TdivideNumFuncName TdivideNumc
#define NumdivideTFuncName NumdivideTc
#define DATATYPENumber 4
#define DATATYPE complex*8
#define NTimeTTYPE 4
#include "templet/multip_divide_plus.f90"
#undef multiplyFuncName
#undef divideFuncName
#undef TplusNumSubroutineFuncName
#undef TminusNumSubroutineFuncName
#undef NumminusTSubroutineFuncName
#undef TplusNumFuncName
#undef NumplusTFuncName
#undef TMinusNumFuncName
#undef NumMinusTFuncName
#undef TmultiplyNumFuncName
#undef NumMultiplyTFuncName
#undef TdivideNumFuncName
#undef NumdivideTFuncName
#undef DATATYPENumber
#undef DATATYPE
#undef NTimeTTYPE

#define multiplyFuncName multiplyz
#define divideFuncName dividez
#define TplusNumSubroutineFuncName TplusNumSubroutinez
#define TminusNumSubroutineFuncName TminusNumSubroutinez
#define NumminusTSubroutineFuncName NumminusTSubroutinez
#define TplusNumFuncName TplusNumz
#define NumplusTFuncName NumplusTz
#define TMinusNumFuncName TMinusNumz
#define NumMinusTFuncName NumMinusTz
#define TmultiplyNumFuncName TmultiplyNumz
#define NumMultiplyTFuncName NumMultiplyTz
#define TdivideNumFuncName TdivideNumz
#define NumdivideTFuncName NumdivideTz
#define DATATYPENumber 5
#define DATATYPE complex*16
#define NTimeTTYPE 5
#include "templet/multip_divide_plus.f90"
#undef multiplyFuncName
#undef divideFuncName
#undef TplusNumSubroutineFuncName
#undef TminusNumSubroutineFuncName
#undef NumminusTSubroutineFuncName
#undef TplusNumFuncName
#undef NumplusTFuncName
#undef TMinusNumFuncName
#undef NumMinusTFuncName
#undef TmultiplyNumFuncName
#undef NumMultiplyTFuncName
#undef TdivideNumFuncName
#undef NumdivideTFuncName
#undef DATATYPENumber
#undef DATATYPE
#undef NTimeTTYPE



	subroutine HtransposeTensor(T,Res)
		class(Tensor),intent(in) :: T
		type(Tensor),intent(inout)::Res
		integer::rank,m,n,i
		integer,allocatable::indices(:)
		integer,pointer::arrow(:)
		rank=T%getRank()
		call conjugateTensor(T,Res)
		if(rank.eq.2) then
			call Res%notFermiPermute([2,1])
		else
			allocate(indices(rank))
			do i=1,rank
				indices(rank-i+1)=i
			end do
			call Res%notFermiPermute(indices)
		end if
		if(Res%getSymmetryFlag()) then
			call hermitian_conjugate_dimension(Res%Dimension)
		end if
		if(Res%getFermiFlag()) then
			call Res%pointArrow(arrow)
			arrow=-arrow
		end if
		return
	end subroutine
	function Htranspose(T)Result(Res)
		type(Tensor),intent(in) :: T
		type(Tensor)::Res
		call HtransposeTensor(T,Res)
		return
	end function
	subroutine HtransposeTensor2(T,Res)
		class(Tensor),intent(in) :: T
		type(Tensor),intent(inout)::Res
		character(len=len_of_name),pointer::names(:)
		integer::rank,i,charlen
		integer,allocatable::indices(:)
		integer,pointer::arrow(:)
		rank=T%getRank()
		call conjugateTensor(T,Res)
		if(rank.eq.2) then
			call Res%notFermiPermute([2,1])
		else
			allocate(indices(rank))
			do i=1,rank
				indices(rank-i+1)=i
			end do
			call Res%notFermiPermute(indices)
		end if
		if(Res%getNameFlag())then
			call Res%pointName(names)
			do i=1,rank
				charlen=len(trim(names(i)))
				if(names(i)(charlen:charlen).eq.dag_mark) then
					names(i)=names(i)(1:charlen-1)
				else
					names(i)=names(i)+dag_mark
				end if
			end do
		end if
		if(Res%getSymmetryFlag()) then
			call hermitian_conjugate_dimension(Res%Dimension)
		end if
		if(Res%getFermiFlag()) then
			call Res%pointArrow(arrow)
			arrow=-arrow
		end if
		return
	end subroutine
	function Htranspose2(T)Result(Res)
		type(Tensor),intent(in) :: T
		type(Tensor)::Res
		call HtransposeTensor2(T,Res)
		return
	end function
	subroutine conjugateTensor(T,Res)
		class(Tensor),intent(in) :: T
		type(Tensor),intent(inout)::Res
		integer :: m
		complex*8,pointer::Rcp(:),Tcp(:)
		complex*16,pointer::Rzp(:),Tzp(:)
		if(.not.T%Data%getFlag())then
			call writemess('ERROR: There is no data in the input tensor',-1)
			call error_stop
		end if
		call Res%allocate(T)
		select case(T%getType())
			case(1)
				Res%Data=T%Data
			case(2)
				Res%Data=T%Data
			case(3)
				Res%Data=T%Data
			case(4)
				call Res%Data%pointAllData(Rcp)
				call T%Data%pointAllData(Tcp)
				Rcp=conjg(Tcp)
			case(5)
				call Res%Data%pointAllData(Rzp)
				call T%Data%pointAllData(Tzp)
				Rzp=dconjg(Tzp)
			case default
		end select
		return
	end subroutine
	function conjugate(T)Result(Res)
		type(Tensor),intent(in) :: T
		type(Tensor)::Res
		call conjugateTensor(T,Res)
		return
	end function
	function absTensor(T)Result(Res)
		type(Tensor),intent(in) :: T
		type(Tensor)::Res
		integer,pointer::ip(:),Rip(:)
		real*4,pointer::sp(:),Rsp(:)
		real*8,pointer::dp(:),Rdp(:)
		complex*8,pointer::cp(:),Rcp(:)
		complex*16,pointer::zp(:),Rzp(:)
		if(.not.T%Data%getFlag())then
			call writemess('ERROR: There is no data in the input tensor',-1)
			call error_stop
		end if
		select case(T%getType())
			case(1)
				call Res%allocate(T)
				call Res%data%pointAllData(Rip)
				call T%Data%pointAllData(ip)
				Rip=abs(ip)
			case(2)
				call Res%allocate(T)
				call Res%data%pointAllData(Rsp)
				call T%Data%pointAllData(sp)
				Rsp=abs(sp)
			case(3)
				call Res%allocate(T)
				call Res%data%pointAllData(Rdp)
				call T%Data%pointAllData(dp)
				Rdp=abs(dp)
			case(4)
				call Res%allocate(T,2)
				call Res%data%pointAllData(Rsp)
				call T%Data%pointAllData(cp)
				Rsp=abs(cp)
			case(5)
				call Res%allocate(T,3)
				call Res%data%pointAllData(Rdp)
				call T%Data%pointAllData(zp)
				Rdp=abs(zp)
		end select
		return
	end function
	function dabsTensor(T)Result(Res)
		type(Tensor),intent(in) :: T
		type(Tensor)::Res
		integer,pointer::ip(:)
		real*4,pointer::sp(:)
		real*8,pointer::dp(:),Rdp(:)
		complex*8,pointer::cp(:)
		complex*16,pointer::zp(:)
		if(.not.T%Data%getFlag())then
			call writemess('ERROR: There is no data in the input tensor',-1)
			call error_stop
		end if
		select case(T%getType())
			case(1)
				call Res%allocate(T,3)
				call Res%data%pointAllData(Rdp)
				call T%Data%pointAllData(ip)
				Rdp=abs(ip)
			case(2)
				call Res%allocate(T,3)
				call Res%data%pointAllData(Rdp)
				call T%Data%pointAllData(sp)
				Rdp=abs(sp)
			case(3)
				call Res%allocate(T)
				call Res%data%pointAllData(Rdp)
				call T%Data%pointAllData(dp)
				Rdp=abs(dp)
			case(4)
				call Res%allocate(T,3)
				call Res%data%pointAllData(Rdp)
				call T%Data%pointAllData(cp)
				Rdp=abs(cp)
			case(5)
				call Res%allocate(T,3)
				call Res%data%pointAllData(Rdp)
				call T%Data%pointAllData(zp)
				Rdp=abs(zp)
		end select
		return
	end function

	integer function select_type_in_add_minu_class_type(classtype1,classtype2)result(Res)
		integer,intent(in)::classtype1,classtype2
		integer::flag
		if(classtype1.eq.classtype2)then
			Res=classtype1
			return
		end if
		if(classtype1.eq.0)then
			Res=classtype2
			return
		end if
		if(classtype2.eq.0)then
			Res=classtype1
			return
		end if
		flag=10*classtype1+classtype2
		select case(flag)
		!int+classtype ---> classtype
			case (12)!int,real4
				Res=2
			case (13)!int,real8
				Res=3
			case (14)!int,compelx(kind=4)
				Res=4
			case (15)!int,compelx(kind=8)
				Res=5
			case (17)!int,character
				Res=7
		!real4+classtype ---> max{2,classtype}
			case (21)!real(kind=4),int
				Res=2
			case (23)!real(kind=4),real8
				Res=3
			case (24)!real(kind=4),compelx(kind=4)
				Res=4
			case (25)!real(kind=4),compelx(kind=8)
				Res=5
			case (27)!real(kind=4),character
				Res=7
		!depend on 		classtype
			case (31)!real(kind=8),int
				Res=3
			case (32)!real(kind=8),real4
				Res=3
			case (34)!real(kind=8),compelx(kind=4)
				Res=5
			case (35)!real(kind=8),compelx(kind=8)
				Res=5
			case (37)!real(kind=8),character
				Res=7
		!depend on 		classtype		
			case (41)!compelx(kind=4),int
				Res=4
			case (42)!compelx(kind=4),real4
				Res=4
			case (43)!compelx(kind=4),real8
				Res=5
			case (45)!compelx(kind=4),compelx(kind=8)
				Res=5
			case (47)!compelx(kind=4),character 
				Res=7
		!complex*16+classtype ---> max{5,classtype}	
			case (51)!compelx(kind=8),int
				Res=5
			case (52)!compelx(kind=8),real4
				Res=5
			case (53)!compelx(kind=8),real8
				Res=5
			case (54)!compelx(kind=8),compelx(kind=4)
				Res=5
			case (57)!compelx(kind=8),character
				Res=7
		!character+classtype ---> max{7,classtype}		
			case (71)!character,int
				Res=7
			case (72)!character,real4
				Res=7
			case (73)!character),real8
				Res=7
			case (74)!character,real4
				Res=7
			case (75)!character),real8
				Res=7
			case (76)!character,logical 
				Res=7
			case default
				write(*,*)"ERROR, no such type in select"
				write(*,*)"flag=",flag
				call error_stop
		end select
		return
	end function

	subroutine plusSubroutine(A,B,num)
		class(Tensor),intent(in)::A
		type(Tensor),intent(in)::B
		class(*),optional,intent(in)::num
		integer::classType,i,ii
		integer,pointer::Aip(:),Bip(:)
		real*4,pointer::Asp(:),Bsp(:)
		real*8,pointer::Adp(:),Bdp(:)
		complex*8,pointer::Acp(:),Bcp(:)
		complex*16,pointer::Azp(:),Bzp(:)
		character(len=characterlen),pointer::Aap(:),Bap(:)
		classType=A%getType()
		select case(classType)
			case(1)
				do i=1,A%getTotalBlock()
					call A%pointer(Aip,i)
					call B%pointer(Bip,i)
					if(associated(Aip).and.associated(Bip))then
						if(present(num))then
							Aip=Aip+Bip*iselect(num)
						else
							Aip=Aip+Bip
						end if
					else if(associated(Aip).or.associated(Bip))then
						call writemess('ERROR in add Tensors',-1)
						call error_stop
					end if
				end do
			case(2)
				do i=1,A%getTotalBlock()
					call A%pointer(Asp,i)
					call B%pointer(Bsp,i)
					if(associated(Asp).and.associated(Bsp))then
						if(present(num))then
							call saxpy (size(Asp), sselect(num), Bsp,1,Asp,1)
						else
							call saxpy (size(Asp), 1., Bsp,1, Asp,1)
						end if
					else if(associated(Asp).or.associated(Bsp))then
						call writemess('ERROR in add Tensors',-1)
						call error_stop
					end if
				end do
			case(3)
				do i=1,A%getTotalBlock()
					call A%pointer(Adp,i)
					call B%pointer(Bdp,i)
					if(associated(Adp).and.associated(Bdp))then
						if(present(num))then
							call daxpy (size(Adp), dselect(num), Bdp,1,Adp,1)
						else
							call daxpy (size(Adp), 1d0, Bdp,1, Adp,1)
						end if
					else if(associated(Adp).or.associated(Bdp))then
						call writemess('ERROR in add Tensors',-1)
						call error_stop
					end if
				end do
			case(4)
				do i=1,A%getTotalBlock()
					call A%pointer(Acp,i)
					call B%pointer(Bcp,i)
					if(associated(Acp).and.associated(Bcp))then
						if(present(num))then
							call caxpy (size(Acp), cselect(num), Bcp,1,Acp,1)
						else
							call caxpy (size(Acp), cmplx(1.,kind=4), Bcp,1, Acp,1)
						end if
					else if(associated(Acp).or.associated(Bcp))then
						call writemess('ERROR in add Tensors',-1)
						call error_stop
					end if
				end do
			case(5)
				do i=1,A%getTotalBlock()
					call A%pointer(Azp,i)
					call B%pointer(Bzp,i)
					if(associated(Azp).and.associated(Bzp))then
						if(present(num))then
							call zaxpy (size(Azp), zselect(num), Bzp,1,Azp,1)
						else
							call zaxpy (size(Azp), dcmplx(1d0), Bzp,1, Azp,1)
						end if
					else if(associated(Azp).or.associated(Bzp))then
						call writemess('ERROR in add Tensors',-1)
						call error_stop
					end if
				end do
			case(7)
				do i=1,A%getTotalBlock()
					call A%pointer(Aap,i)
					call B%pointer(Bap,i)
					if(associated(Aap).and.associated(Bap))then
						if(present(num))then
							call writemess('ERROR in add Tensors',-1)
							call error_stop
						else
							do ii=1,size(Aap)
								Aap(ii)=Aap(ii)+Bap(ii)
							end do
						end if
					else if(associated(Aap).or.associated(Bap))then
						call writemess('ERROR in add Tensors',-1)
						call error_stop
					end if
				end do
			case default
				call writemess('ERROR in add Tensor, datatpye='+classType,-1)
				call error_stop
		end select
		return
	end subroutine
	function plusTensor(A,B)result(Res)
		type(Tensor),intent(in)::A
		type(Tensor),intent(in)::B
		type(Tensor)::Res
		integer::i,Blocklen,NewClassType,TotalDAta
		class(*),pointer::Rp(:),Ap(:),Bp(:)
		if(.not.(A%getFlag().or.B%getFlag()))then
			call Res%empty()
			return
		end if
		NewClassType=select_type_in_add_minu_class_type(A%getType(),B%getType())
		if((.not.A%getSymmetryFlag()).and.(.not.B%getSymmetryFlag()))then
			if(A%Data%getFlag().and.B%Data%getFlag())then
				TotalDAta=A%getTotalData()
				if(TotalDAta.ne.B%getTotalData())then
					call writemess('ERROR in Tensor + Tensor, totalData',-1)
					call writemess('A%getTotalData()='+A%getTotalData(),-1)
					call writemess('B%getTotalData()='+B%getTotalData(),-1)
					call error_stop
				end if
				call Res%allocate(A,NewClassType)
				call ClassPlusClass(Res%Data%ClassData,A%Data%ClassData,B%Data%ClassData,TotalData)
			else if(A%Data%getFlag())then
				Res=A
			else if(B%Data%getFlag())then
				Res=B
			end if
			return
		end if
		if((.not.A%data%getFlag()).and.(.not.B%data%getFlag()))then
			call Res%empty()
			return
		end if
		if(A%data%getFlag().and.(.not.B%data%getFlag()))then
			Res=A
			return
		end if
		if(B%data%getFlag().and.(.not.A%data%getFlag()))then
			Res=B
			return
		end if

		if(A%getFlag().and.(.not.B%getFlag()))then
			Res=A
			return
		end if
		if(B%getFlag().and.(.not.A%getFlag()))then
			Res=B
			return
		end if
		TotalData=min(A%getTotalData()+B%getTotalData(),A%getTotalVolume())
		call Res%allocatemomery(A%Dimension,TotalData,NewClassType)
		do i=1,A%getTotalBlock()
			call A%classPointer(Ap,i)
			call B%classPointer(Bp,i)
			if(associated(Ap).or.associated(Bp))then
				if(associated(Ap).and.associated(Bp))then
					Blocklen=A%getTotalData(i)
					call Res%Data%Set_block_momery(i,Blocklen)
					call Res%Data%classPointer(Rp,i)
					call ClassPlusClass(Rp,Ap,Bp,Blocklen)
				else  if(associated(Ap))then
					Blocklen=A%getTotalData(i)
					call Res%Data%Set_block_momery(i,Blocklen)
					call Res%Data%classPointer(Rp,i)
					call FastcopyARRAY(Rp,Ap,Blocklen)
				else
					Blocklen=B%getTotalData(i)
					call Res%Data%Set_block_momery(i,Blocklen)
					call Res%Data%classPointer(Rp,i)
					call FastcopyARRAY(Rp,Bp,Blocklen)
				end if
			end if
		end do
		return
	end function

	function TplusNuma(A,B)result(Res)
		type(Tensor)::Res
		type(Tensor),intent(in)::A
		character(len=*),intent(in)::B
		if(.not.A%Data%getFlag())then
			call writemess('ERROR: There is no data in the input tensor',-1)
			call error_stop
		end if
		call Res%Allocate(A,select_type_in_add_minu_class_type(A%getType(),7))
		call ClassPlusnum(Res%Data%ClassData,A%Data%ClassData,B,A%getTotalData())
		return
	end function
	function NumplusTa(B,A)result(Res)
		type(Tensor)::Res
		character(len=*),intent(in)::B
		type(Tensor),intent(in)::A
		if(.not.A%Data%getFlag())then
			call writemess('ERROR: There is no data in the input tensor',-1)
			call error_stop
		end if
		call Res%Allocate(A,select_type_in_add_minu_class_type(A%getType(),7))
		call numPlusClass(Res%Data%ClassData,B,A%Data%ClassData,A%getTotalData())
		return
	end function

	function TdivideT(A,B)result(Res)
		type(Tensor)::Res
		type(Tensor),intent(in)::A
		type(Tensor),intent(in)::B
		class(*),pointer::p0
		if(.not.A%Data%getFlag())then
			call writemess('ERROR: There is no data in the input tensor',-1)
			call error_stop
		end if
		if(.not.B%Data%getFlag())then
			call writemess('ERROR: There is no data in the input tensor',-1)
			call error_stop
		end if
		if(B%getTotalData().ne.1)then
			call writemess('ERROR in Tensor/Tensor2, the totalData in Tensor2 should be 1',-1)
			call error_stop
		end if
		call Res%allocate(A,select_type_in_add_minu_class_type(A%getType(),B%getType()))
		call ClassPointer1DFunc(B%Data%ClassData,1,p0)
		call Classdividenum(Res%Data%ClassData,A%Data%ClassData,p0,A%getTotalData())
		return
	end function

	subroutine TdivideTsubroutine(A,B)
		class(Tensor),intent(inout)::A
		type(Tensor),intent(in)::B
		integer::iB
		real*4::sB
		real*8::dB
		complex*8::cB
		complex*16::zB
		if(B%getTotalData().ne.1)then
			call writemess('ERROR in Tensor/Tensor2, the totalData in Tensor2 should be 1',-1)
			call error_stop
		end if
		select case(A%getType())
			case(1)
				iB=B
				call dividei(A,iB)
			case(2)
				sB=B
				call divides(A,sB)
			case(3)
				dB=B
				call divided(A,dB)
			case(4)
				cB=B
				call dividec(A,cB)
			case(5)
				zB=B
				call dividez(A,zB)
			case default
				call writemess('ERROR in Tensor/Tensor2, datatype='+A%getType(),-1)
				call error_stop
		end select
		return
	end subroutine


	function minusTensor(A,B)result(Res)
		type(Tensor),intent(in)::A
		type(Tensor),intent(in)::B
		type(Tensor)::Res
			class(*),pointer::Rp(:),Ap(:),Bp(:)
		integer::i,NewClassType,Blocklen,TotalData
		NewClassType=select_type_in_add_minu_class_type(A%getType(),B%getType())
		if((.not.A%getSymmetryFlag()).and.(.not.B%getSymmetryFlag()))then
			if(A%Data%getFlag().and.B%Data%getFlag())then
				TotalData=A%getTotalData()
				if(A%getTotalData().ne.B%getTotalData())then
					call writemess('ERROR in Tensor + Tensor, totalData',-1)
					call writemess('A%getTotalData()='+A%getTotalData(),-1)
					call writemess('B%getTotalData()='+B%getTotalData(),-1)
					call error_stop
				end if
				call Res%allocate(A,NewClassType)
				call ClassMinusClass(Res%Data%ClassData,A%Data%ClassData,B%Data%ClassData,TotalData)
			else if(A%Data%getFlag())then
				TotalData=A%getTotalData()
				call Res%allocate(A,NewClassType)
				call FastCopyArray(Res%Data%ClassData,A%Data%ClassData,TotalData)
			else
				TotalData=B%getTotalData()
				call Res%allocate(B,NewClassType)
				call numMinusClass(Res%Data%ClassData,0,B%Data%ClassData,TotalData)
			end if
			return
		end if
		if(A%getFlag())then
			call Res%allocatemomery(A%Dimension,A%getTotalData()+B%getTotalData(),A%getType())
		else if(B%getFlag())then
			call Res%allocatemomery(B%Dimension,A%getTotalData()+B%getTotalData(),B%getType())
		else
			call Res%empty()
			return
		end if
		do i=1,A%getTotalBlock()
			call A%classPointer(Ap,i)
			call B%classPointer(Bp,i)
			if(associated(Ap).or.associated(Bp))then
				if(associated(Ap).and.associated(Bp))then
					Blocklen=A%getTotalData(i)
					call Res%Data%Set_block_momery(i,Blocklen)
					call Res%Data%classPointer(Rp,i)
					call ClassMinusClass(Rp,Ap,Bp,Blocklen)
				else  if(associated(Ap))then
					Blocklen=A%getTotalData(i)
					call Res%Data%Set_block_momery(i,Blocklen)
					call Res%Data%classPointer(Rp,i)
					call FastcopyARRAY(Rp,Ap,Blocklen)
				else
					Blocklen=B%getTotalData(i)
					call Res%Data%Set_block_momery(i,Blocklen)
					call Res%Data%classPointer(Rp,i)
					call numMinusClass(Rp,0,Bp,Blocklen)
				end if
			end if
		end do
		return
	end function

	subroutine directProduct(A_,B_,Res)
		type(Tensor),target,intent(in)::A_,B_
		type(Tensor),pointer::A,B
		type(Tensor),intent(inout)::Res
		integer,pointer::Aip(:),Bip(:),Rip(:)
		real*4,pointer::Asp(:),Bsp(:),Rsp(:)
		real*8,pointer::Adp(:),Bdp(:),Rdp(:)
		complex*8,pointer::Acp(:),Bcp(:),Rcp(:)
		complex*16,pointer::Azp(:),Bzp(:),Rzp(:)
		integer::i,j,k,classType,blocki,blockj,rankA,rankB
		integer::TotalA,totalB,TotalR,BlockLenA,BlockLenB,BlockLenR
		integer,pointer::dim(:),indexA(:),indexB(:),indexRes(:),dimA(:),dimB(:)
		logical::goonB,goonA
		call pointToTensorWithRightType(A,B,A_,B_,TMPdirectProductA,TMPdirectProductB)
		classType=A%getType()
		if(classType.ne.B%getType())then
			call writemess('ERROR in directProductTensor,classType',-1)
			call writemess('A%getType()='+A%getType(),-1)
			call writemess('B%getType()='+B%getType(),-1)
			call error_stop
		end if
		if(.not.A%Data%getFlag())then
			call writemess('ERROR in directProductTensor,the first tensor is empty',-1)
			call error_stop
		end if
		if(.not.B%Data%getFlag())then
			call writemess('ERROR in directProductTensor,the second tensor is empty',-1)
			call error_stop
		end if
		rankA=A%getRank()
		rankB=B%getRank()
		TotalA=A%getTotalData()
		TotalB=B%getTotalData()
		TotalR=TotalA*TotalB
		call WorkingMemory%check()
		call WorkingMemory%allocate(1,rankA+rankB+rankA+rankB)
		call WorkingMemory%get_Memory(indexA,rankA)
		call WorkingMemory%get_Memory(indexB,rankB)
		call WorkingMemory%get_Memory(indexRes,rankA+rankB)
		call pasteDimension(Res%Dimension,A%Dimension,1,rankA,B%dimension,1,rankB)
		if(.not.Res%getSymmetryFlag())then
			call Res%pointDim(dim)
			call Res%Data%allocate(product(dim),classType)
			call A%pointDim(DimA)
			call B%pointDim(DimB)
			select case(classType)
				case(1)
					call A%pointer(Aip)
					call B%pointer(Bip)
					call Res%pointer(Rip)
					k=0
					do j=1,B%getTotalData()
						do i=1,A%getTotalData()
							k=k+1
							Rip(k)=Aip(i)*Bip(j)
						end do
					end do
				case(2)
					call A%pointer(Asp)
					call B%pointer(Bsp)
					call Res%pointer(Rsp)
					k=0
					do j=1,B%getTotalData()
						do i=1,A%getTotalData()
							k=k+1
							Rsp(k)=Asp(i)*Bsp(j)
						end do
					end do
				case(3)
					call A%pointer(Adp)
					call B%pointer(Bdp)
					call Res%pointer(Rdp)
					k=0
					do j=1,B%getTotalData()
						do i=1,A%getTotalData()
							k=k+1
							Rdp(k)=Adp(i)*Bdp(j)
						end do
					end do
				case(4)
					call A%pointer(Acp)
					call B%pointer(Bcp)
					call Res%pointer(Rcp)
					k=0
					do j=1,B%getTotalData()
						do i=1,A%getTotalData()
							k=k+1
							Rcp(k)=Acp(i)*Bcp(j)
						end do
					end do
				case(5)
					call A%pointer(Azp)
					call B%pointer(Bzp)
					call Res%pointer(Rzp)
					k=0
					do j=1,B%getTotalData()
						do i=1,A%getTotalData()
							k=k+1
							Rzp(k)=Azp(i)*Bzp(j)
						end do
					end do
				case default
					call writemess('ERROR in directProductTensor,classType',-1)
					call writemess('A%getType()='+A%getType(),-1)
					call writemess('B%getType()='+B%getType(),-1)
					call error_stop
			end select
			call WorkingMemory%free()
			return
		end if



		call Res%pointDim(dim)
		call Res%Data%allocateDataArrayMomery(product(dim),TotalR,classType)
		indexA=1
		indexB=1
		call A%pointDim(DimA)
		call B%pointDim(DimB)
		goonB=.true.
		select case(classType)
			case(1)
				do blockj=1,B%getTotalBlock()
					indexA=1
					goonA=.true.
					if(.not.goonB)then
						call writemess('ERROR in .kron.',-1)
						call error_stop
					end if
					call B%pointer(Bip,blockj)
					if(associated(Bip))then
						BlockLenB=size(Bip)
						do blocki=1,A%getTotalBlock()
							if(.not.goonA)then
								call writemess('ERROR in .kron.',-1)
								call error_stop
							end if
							call A%pointer(Aip,blocki)
							if(associated(Aip))then
								BlockLenA=size(Aip)
								BlockLenR=BlockLenA*BlockLenB
								indexRes=[indexA,indexB]
								call Res%setBlockMomery(indexRes)
								call Res%pointer(Rip,indexRes)
								if(size(Rip).ne.BlockLenR)then
									call writemess('ERROR in .kron.',-1)
									call error_stop
								end if
								k=0
								do j=1,BlockLenB
									do i=1,BlockLenA
										k=k+1
										Rip(k)=Aip(i)*Bip(j)
									end do
								end do
							end if
							goonA=index_counter(indexA,dimA)
						end do
					end if
					goonB=index_counter(indexB,dimB)
				end do
			case(2)
				do blockj=1,B%getTotalBlock()
					indexA=1
					goonA=.true.
					if(.not.goonB)then
						call writemess('ERROR in .kron.',-1)
						call error_stop
					end if
					call B%pointer(Bsp,blockj)
					if(associated(Bsp))then
						BlockLenB=size(Bsp)
						do blocki=1,A%getTotalBlock()
							if(.not.goonA)then
								call writemess('ERROR in .kron.',-1)
								call error_stop
							end if
							call A%pointer(Asp,blocki)
							if(associated(Asp))then
								BlockLenA=size(Asp)
								BlockLenR=BlockLenA*BlockLenB
								indexRes=[indexA,indexB]
								call Res%setBlockMomery(indexRes)
								call Res%pointer(Rsp,indexRes)
								if(size(Rsp).ne.BlockLenR)then
									call writemess('ERROR in .kron.',-1)
									call error_stop
								end if
								k=0
								do j=1,BlockLenB
									do i=1,BlockLenA
										k=k+1
										Rsp(k)=Asp(i)*Bsp(j)
									end do
								end do
							end if
							goonA=index_counter(indexA,dimA)
						end do
					end if
					goonB=index_counter(indexB,dimB)
				end do
			case(3)
				do blockj=1,B%getTotalBlock()
					indexA=1
					goonA=.true.
					if(.not.goonB)then
						call writemess('ERROR in .kron.',-1)
						call error_stop
					end if
					call B%pointer(Bdp,blockj)
					if(associated(Bdp))then
						BlockLenB=size(Bdp)
						do blocki=1,A%getTotalBlock()
							if(.not.goonA)then
								call writemess('ERROR in .kron.',-1)
								call error_stop
							end if
							call A%pointer(Adp,blocki)
							if(associated(Adp))then
								BlockLenA=size(Adp)
								BlockLenR=BlockLenA*BlockLenB
								indexRes=[indexA,indexB]
								call Res%setBlockMomery(indexRes)
								call Res%pointer(Rdp,indexRes)
								if(size(Rdp).ne.BlockLenR)then
									call writemess('ERROR in .kron.',-1)
									call error_stop
								end if
								k=0
								do j=1,BlockLenB
									do i=1,BlockLenA
										k=k+1
										Rdp(k)=Adp(i)*Bdp(j)
									end do
								end do
							end if
							goonA=index_counter(indexA,dimA)
						end do
					end if
					goonB=index_counter(indexB,dimB)
				end do
			case(4)
				do blockj=1,B%getTotalBlock()
					indexA=1
					goonA=.true.
					if(.not.goonB)then
						call writemess('ERROR in .kron.',-1)
						call error_stop
					end if
					call B%pointer(Bcp,blockj)
					if(associated(Bcp))then
						BlockLenB=size(Bcp)
						do blocki=1,A%getTotalBlock()
							if(.not.goonA)then
								call writemess('ERROR in .kron.',-1)
								call error_stop
							end if
							call A%pointer(Acp,blocki)
							if(associated(Acp))then
								BlockLenA=size(Acp)
								BlockLenR=BlockLenA*BlockLenB
								indexRes=[indexA,indexB]
								call Res%setBlockMomery(indexRes)
								call Res%pointer(Rcp,indexRes)
								if(size(Rcp).ne.BlockLenR)then
									call writemess('ERROR in .kron.',-1)
									call error_stop
								end if
								k=0
								do j=1,BlockLenB
									do i=1,BlockLenA
										k=k+1
										Rcp(k)=Acp(i)*Bcp(j)
									end do
								end do
							end if
							goonA=index_counter(indexA,dimA)
						end do
					end if
					goonB=index_counter(indexB,dimB)
				end do
			case(5)
				do blockj=1,B%getTotalBlock()
					indexA=1
					goonA=.true.
					if(.not.goonB)then
						call writemess('ERROR in .kron.',-1)
						call error_stop
					end if
					call B%pointer(Bzp,blockj)
					if(associated(Bzp))then
						BlockLenB=size(Bzp)
						do blocki=1,A%getTotalBlock()
							if(.not.goonA)then
								call writemess('ERROR in .kron.',-1)
								call error_stop
							end if
							call A%pointer(Azp,blocki)
							if(associated(Azp))then
								BlockLenA=size(Azp)
								BlockLenR=BlockLenA*BlockLenB
								indexRes=[indexA,indexB]
								call Res%setBlockMomery(indexRes)
								call Res%pointer(Rzp,indexRes)
								if(size(Rzp).ne.BlockLenR)then
									call writemess('ERROR in .kron.',-1)
									call writemess('size(Rzp)='+size(Rzp),-1)
									call writemess('BlockLenR='+BlockLenR,-1)
									call error_stop
								end if
								k=0
								do j=1,BlockLenB
									do i=1,BlockLenA
										k=k+1
										Rzp(k)=Azp(i)*Bzp(j)
									end do
								end do
							end if
							goonA=index_counter(indexA,dimA)
						end do
					end if
					goonB=index_counter(indexB,dimB)
				end do
			case default
				call writemess('ERROR in directProductTensor,classType',-1)
				call writemess('A%getType()='+A%getType(),-1)
				call writemess('B%getType()='+B%getType(),-1)
				call error_stop
		end select
		call WorkingMemory%free()
	end subroutine

	function directProducttensor(A,B)result(Res)
		type(Tensor)::Res
		type(Tensor),intent(in)::A,B
		call directProduct(A,B,Res)
	end function


	function iszero(A)
		logical::iszero
		class(Tensor),intent(in)::A
		integer::i
		integer,pointer::Aip(:)
		real*4,pointer::Asp(:)
		real*8,pointer::Adp(:)
		complex*8,pointer::Acp(:)
		complex*16,pointer::Azp(:)
		if(.not.A%Data%getFlag())then
			call writemess('ERROR: There is no data in the input tensor',-1)
			call error_stop
		end if
		iszero=.true.
		select case(A%getType())
			case(1)
				call A%Data%pointAllData(Aip)
				do i=1,A%getTotalData()
					if(Aip(i).ne.0 )then
						iszero=.false.
						return
					end if
				end do
			case(2)
				call A%Data%pointAllData(Asp)
				do i=1,A%getTotalData()
					if(abs(Asp(i)).ge.default_zero_real_number)then
						iszero=.false.
						return
					end if
				end do
			case(3)
				call A%Data%pointAllData(Adp)
				do i=1,A%getTotalData()
					if(dabs(Adp(i)).ge.default_zero_double_number )then
						iszero=.false.
						return
					end if
				end do
			case(4)
				call A%Data%pointAllData(Acp)
				do i=1,A%getTotalData()
					if((abs(real(Acp(i),kind=4)).ge.default_zero_real_number).or.(abs(aimag(Acp(i)))&
												.ge.default_zero_real_number ) )then
						iszero=.false.
						return
					end if
				end do
			case(5)
				call A%Data%pointAllData(Azp)
				do i=1,A%getTotalData()
					if((dabs(dble(Azp(i))).ge.default_zero_double_number ).or.(dabs(dimag(Azp(i))).ge.&
									default_zero_double_number) )then
						iszero=.false.
						return
					end if
				end do
			case default
				call writemess(" ERROR in iszero,Tensor is not number type(integer, real or complex)",-1)
				call error_stop
		end select
	end function


