#define FuncName1 iPointer1
#define FuncName2 iPointer2
#define FuncName3 iPointer3
#define FuncName4 iPointer4
#define FuncName5 iPointer5
#define FuncBlockName_vec iPointer_vec
#define PrintName iprint
#define StoreDataType  iStoreData
#define StoreSomeDataType  iStoreSomeData
#define FuncBlockName1 iPointerBlock1
#define FuncBlockName2 iPointerBlock2
#define FuncBlockName3 iPointerBlock3
#define FuncBlockName4 iPointerBlock4
#define FuncDimBlockName2 iPointerDimBlock2
#define FuncDimBlockName3 iPointerDimBlock3
#define FuncDataType integer
#define FuncDataType2 integer
#define DATATYPENum 1
#include "templet/Tensor_pointer_subroutine0.f90"
#undef FuncName1
#undef FuncName2
#undef FuncName3
#undef FuncName4
#undef FuncName5
#undef FuncBlockName_vec
#undef PrintName
#undef StoreDataType
#undef StoreSomeDataType
#undef FuncBlockName1
#undef FuncBlockName2
#undef FuncBlockName3
#undef FuncBlockName4
#undef FuncDimBlockName2
#undef FuncDimBlockName3
#undef DATATYPENum
#undef FuncDataType
#undef FuncDataType2


#define FuncName1 sPointer1
#define FuncName2 sPointer2
#define FuncName3 sPointer3
#define FuncName4 sPointer4
#define FuncName5 sPointer5
#define FuncBlockName_vec sPointer_vec
#define PrintName sprint
#define StoreDataType  sStoreData
#define StoreSomeDataType  sStoreSomeData
#define FuncBlockName1 sPointerBlock1
#define FuncBlockName2 sPointerBlock2
#define FuncBlockName3 sPointerBlock3
#define FuncBlockName4 sPointerBlock4
#define FuncDimBlockName2 sPointerDimBlock2
#define FuncDimBlockName3 sPointerDimBlock3
#define FuncDataType real*4
#define FuncDataType2 real*4
#define DATATYPENum 2
#include "templet/Tensor_pointer_subroutine0.f90"
#undef FuncName1
#undef FuncName2
#undef FuncName3
#undef FuncName4
#undef FuncName5
#undef FuncBlockName_vec
#undef PrintName
#undef StoreDataType
#undef StoreSomeDataType
#undef FuncBlockName1
#undef FuncBlockName2
#undef FuncBlockName3
#undef FuncBlockName4
#undef FuncDimBlockName2
#undef FuncDimBlockName3
#undef DATATYPENum
#undef FuncDataType
#undef FuncDataType2


#define FuncName1 dPointer1
#define FuncName2 dPointer2
#define FuncName3 dPointer3
#define FuncName4 dPointer4
#define FuncName5 dPointer5
#define FuncBlockName_vec dPointer_vec
#define PrintName dprint
#define StoreDataType  dStoreData
#define StoreSomeDataType  dStoreSomeData
#define FuncBlockName1 dPointerBlock1
#define FuncBlockName2 dPointerBlock2
#define FuncBlockName3 dPointerBlock3
#define FuncBlockName4 dPointerBlock4
#define FuncDimBlockName2 dPointerDimBlock2
#define FuncDimBlockName3 dPointerDimBlock3
#define FuncDataType real*8
#define FuncDataType2 real*8
#define DATATYPENum 3
#include "templet/Tensor_pointer_subroutine0.f90"
#undef FuncName1
#undef FuncName2
#undef FuncName3
#undef FuncName4
#undef FuncName5
#undef FuncBlockName_vec
#undef PrintName
#undef StoreDataType
#undef StoreSomeDataType
#undef FuncBlockName1
#undef FuncBlockName2
#undef FuncBlockName3
#undef FuncBlockName4
#undef FuncDimBlockName2
#undef FuncDimBlockName3
#undef DATATYPENum
#undef FuncDataType
#undef FuncDataType2



#define FuncName1 cPointer1
#define FuncName2 cPointer2
#define FuncName3 cPointer3
#define FuncName4 cPointer4
#define FuncName5 cPointer5
#define FuncBlockName_vec cPointer_vec
#define PrintName cprint
#define StoreDataType  cStoreData
#define StoreSomeDataType  cStoreSomeData
#define FuncBlockName1 cPointerBlock1
#define FuncBlockName2 cPointerBlock2
#define FuncBlockName3 cPointerBlock3
#define FuncBlockName4 cPointerBlock4
#define FuncDimBlockName2 cPointerDimBlock2
#define FuncDimBlockName3 cPointerDimBlock3
#define FuncDataType complex*8
#define FuncDataType2 complex*8
#define DATATYPENum 4
#include "templet/Tensor_pointer_subroutine0.f90"
#undef FuncName1
#undef FuncName2
#undef FuncName3
#undef FuncName4
#undef FuncName5
#undef FuncBlockName_vec
#undef PrintName
#undef StoreDataType
#undef StoreSomeDataType
#undef FuncBlockName1
#undef FuncBlockName2
#undef FuncBlockName3
#undef FuncBlockName4
#undef FuncDimBlockName2
#undef FuncDimBlockName3
#undef DATATYPENum
#undef FuncDataType
#undef FuncDataType2



#define FuncName1 zPointer1
#define FuncName2 zPointer2
#define FuncName3 zPointer3
#define FuncName4 zPointer4
#define FuncName5 zPointer5
#define FuncBlockName_vec zPointer_vec
#define PrintName zprint
#define StoreDataType  zStoreData
#define StoreSomeDataType  zStoreSomeData
#define FuncBlockName1 zPointerBlock1
#define FuncBlockName2 zPointerBlock2
#define FuncBlockName3 zPointerBlock3
#define FuncBlockName4 zPointerBlock4
#define FuncDimBlockName2 zPointerDimBlock2
#define FuncDimBlockName3 zPointerDimBlock3
#define FuncDataType complex*16
#define FuncDataType2 complex*16
#define DATATYPENum 5
#include "templet/Tensor_pointer_subroutine0.f90"
#undef FuncName1
#undef FuncName2
#undef FuncName3
#undef FuncName4
#undef FuncName5
#undef FuncBlockName_vec
#undef PrintName
#undef StoreDataType
#undef StoreSomeDataType
#undef FuncBlockName1
#undef FuncBlockName2
#undef FuncBlockName3
#undef FuncBlockName4
#undef FuncDimBlockName2
#undef FuncDimBlockName3
#undef DATATYPENum
#undef FuncDataType
#undef FuncDataType2



#define FuncName1 lPointer1
#define FuncName2 lPointer2
#define FuncName3 lPointer3
#define FuncName4 lPointer4
#define FuncName5 lPointer5
#define FuncBlockName_vec lPointer_vec
#define PrintName lprint
#define StoreDataType  lStoreData
#define StoreSomeDataType  lStoreSomeData
#define FuncBlockName1 lPointerBlock1
#define FuncBlockName2 lPointerBlock2
#define FuncBlockName3 lPointerBlock3
#define FuncBlockName4 lPointerBlock4
#define FuncDimBlockName2 lPointerDimBlock2
#define FuncDimBlockName3 lPointerDimBlock3
#define FuncDataType logical
#define FuncDataType2 logical
#define DATATYPENum 6
#include "templet/Tensor_pointer_subroutine0.f90"
#undef FuncName1
#undef FuncName2
#undef FuncName3
#undef FuncName4
#undef FuncName5
#undef FuncBlockName_vec
#undef PrintName
#undef StoreDataType
#undef StoreSomeDataType
#undef FuncBlockName1
#undef FuncBlockName2
#undef FuncBlockName3
#undef FuncBlockName4
#undef FuncDimBlockName2
#undef FuncDimBlockName3
#undef DATATYPENum
#undef FuncDataType
#undef FuncDataType2


#define FuncName1 aPointer1
#define FuncName2 aPointer2
#define FuncName3 aPointer3
#define FuncName4 aPointer4
#define FuncName5 aPointer5
#define FuncBlockName_vec aPointer_vec
#define PrintName aprint
#define StoreDataType  aStoreData
#define StoreSomeDataType  aStoreSomeData
#define FuncBlockName1 aPointerBlock1
#define FuncBlockName2 aPointerBlock2
#define FuncBlockName3 aPointerBlock3
#define FuncBlockName4 aPointerBlock4
#define FuncDimBlockName2 aPointerDimBlock2
#define FuncDimBlockName3 aPointerDimBlock3
#define FuncDataType character(len=*)
#define FuncDataType2 character(len=characterlen)
#define DATATYPENum 7
#include "templet/Tensor_pointer_subroutine0.f90"
#undef FuncName1
#undef FuncName2
#undef FuncName3
#undef FuncName4
#undef FuncName5
#undef FuncBlockName_vec
#undef PrintName
#undef StoreDataType
#undef StoreSomeDataType
#undef FuncBlockName1
#undef FuncBlockName2
#undef FuncBlockName3
#undef FuncBlockName4
#undef FuncDimBlockName2
#undef FuncDimBlockName3
#undef DATATYPENum
#undef FuncDataType
#undef FuncDataType2





#define TAT_FUNCNAME tensor_transpose_real4
#define TAT_TYPENAME real*4
#include "templet/tensor_transpose.include.f90"
#undef TAT_FUNCNAME
#undef TAT_TYPENAME
#define TAT_FUNCNAME tensor_transpose_real8
#define TAT_TYPENAME real*8
#include "templet/tensor_transpose.include.f90"
#undef TAT_FUNCNAME
#undef TAT_TYPENAME
#define TAT_FUNCNAME tensor_transpose_complex8
#define TAT_TYPENAME complex*8
#include "templet/tensor_transpose.include.f90"
#undef TAT_FUNCNAME
#undef TAT_TYPENAME
#define TAT_FUNCNAME tensor_transpose_complex16
#define TAT_TYPENAME complex*16
#include "templet/tensor_transpose.include.f90"
#undef TAT_FUNCNAME
#undef TAT_TYPENAME
#define TAT_FUNCNAME tensor_transpose_int
#define TAT_TYPENAME integer
#include "templet/tensor_transpose.include.f90"
#undef TAT_FUNCNAME
#undef TAT_TYPENAME
#define TAT_FUNCNAME tensor_transpose_logical
#define TAT_TYPENAME logical
#include "templet/tensor_transpose.include.f90"
#undef TAT_FUNCNAME
#undef TAT_TYPENAME
#define TAT_FUNCNAME tensor_transpose_string
#define TAT_TYPENAME character(len=*)
#include "templet/tensor_transpose.include.f90"
#undef TAT_FUNCNAME
#undef TAT_TYPENAME
	


	subroutine ClassPrint(ip,dim,w)
		class(*),target,intent(in)::ip(:)
		integer,intent(in)::dim(:)
		character(len=*),optional,intent(in)::w
		class(*),pointer::ip2(:,:),ip3(:,:,:),ip4(:,:,:,:)
		integer::rank,i,j,k
		rank=size(dim)
		select case(rank)
			case (1)
				if(present(w))then
					call ClassWritemess(ip,w)
				else
					call ClassWritemess(ip)
				end if
			case (2)
				call ClassPointer2DFunc(classSize(ip),ip,dim(1),dim(2),ip2)
				do i=1,dim(1)
					if(present(w))then
						call ClassWritemess(ip2(i,:),w)
					else
						call ClassWritemess(ip2(i,:))
					end if
				end do
			case (3)
				call ClassPointer3DFunc(classSize(ip),ip,dim(1),dim(2),dim(3),ip3)
				do j=1,dim(3)
					call writemess('(*,*,'+j+')')
					do i=1,dim(1)
						if(present(w))then
							call ClassWritemess(ip3(i,:,j),w)
						else
							call ClassWritemess(ip3(i,:,j))
						end if
					end do
				end do
			case (4)
				call ClassPointer4DFunc(classSize(ip),ip,dim(1),dim(2),dim(3),dim(4),ip4)
				do k=1,dim(4)
					do j=1,dim(3)
						call writemess('(*,*,'+j+','+k+')')
						do i=1,dim(1)
							if(present(w))then
								call ClassWritemess(ip4(i,:,j,k),w)
							else
								call ClassWritemess(ip4(i,:,j,k))
							end if
						end do
					end do
				end do
			case default
				if(present(w))then
					call ClassWritemess(ip,w)
				else
					call ClassWritemess(ip)
				end if
				call writemess('dimension:')
				call writemess(dim)
		end select
		return
	end subroutine
	subroutine ClassStoreData(A,Block,indexstart,indexend,Dim)
		class(*),intent(inout)::A(:)
		class(*),intent(in)::Block(:)
		integer,intent(in)::indexstart(:),indexend(:),Dim(:)
		integer,allocatable::indices(:)
		logical::goon
		integer::ith,Blockith
		class(*),pointer::Ap,Blockp
		allocate(indices(size(indexstart)))

		indices=indexstart
		goon=.true.
		Blockith=0
		do while(goon)
			ith=addressToIndes(indices,dim)
			Blockith=Blockith+1
			if(Blockith.gt.size(Block))then
				call writemess("ERROR in StoreData,SymTensor",-1)
				call writemess('size(Block)='+size(Block),-1)
				call writemess('Blockith='+Blockith,-1)
				call writemess('indexstart, indexend and dim are',-1)
				call writemess(indexstart,-1)
				call writemess(indexend,-1)
				call writemess(Dim,-1)
				call error_Stop()
			end if
			call ClassPointer1DFunc(A,ith,Ap)
			call ClassPointer1DFunc(Block,Blockith,Blockp)
			call CopyData(Ap,Blockp)
			!A(ith)=Block(Blockith)
			goon=index_counter(indices,indexstart,indexend,1)
		end do
		return
	end subroutine
	subroutine ClassStoreSomeData(A,dimA,Block,dimBlock,indexstart,indexend,Dims,dime)
		class(*),intent(inout)::A(:)
		class(*),intent(in)::Block(:)
		integer,intent(in)::indexstart(:),indexend(:),Dims(:),dime(:),dimA(:),dimBlock(:)
		integer,allocatable::indices(:),indices2(:)
		logical::goon,goon2
		integer::ith,Blockith
		class(*),pointer::Ap,Blockp
		allocate(indices(size(indexstart)))
		allocate(indices2(size(Dims)))

		indices=indexstart
		indices2=Dims
		goon=.true.
		Blockith=0
		do while(goon)
			ith=addressToIndes(indices,dimA)
			Blockith=addressToIndes(indices2,dimBlock)
			if(Blockith.gt.size(Block))then
				call writemess("ERROR in StoreData,SymTensor",-1)
				call writemess('size(Block)='+size(Block),-1)
				call writemess('Blockith='+Blockith,-1)
				call error_Stop()
			end if
			call ClassPointer1DFunc(A,ith,Ap)
			call ClassPointer1DFunc(Block,Blockith,Blockp)
			call CopyData(Ap,Blockp)
			!A(ith)=Block(Blockith)
			goon=index_counter(indices,indexstart,indexend,1)
			goon2=index_counter(indices2,Dims,dime,1)
		end do
		return
	end subroutine

	subroutine Tensor1DclassPointer(A,p)
		class(Tensor)::A
		class(*),pointer::p(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		call ClassPointer1DFunc(A%getTotalData(),A%Data%ClassData,p)
		return
	end subroutine

	subroutine Tensor2DclassPointer(A,p)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:,:)
		integer,pointer::dim(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(A%Data%getTotalBlock().ne.1)then
			call writemess(' The Tensor is Symmetry type, error pointting',-1)
			call error_stop
		end if
		if(A%getRank().ne.2)then
			call writemess('ERROR in Tensor%pointer, rank',-1)
			call writemess('A%getRank()='+A%getRank())
			call error_stop
		end if
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		call A%pointDim(dim)
		call ClassPointer2DFunc(A%getTotalData(),A%Data%ClassData,dim(1),dim(2),p)
		return
	end subroutine

	subroutine Tensor3DclassPointer(A,p)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:,:,:)
		integer,pointer::dim(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(A%Data%getTotalBlock().ne.1)then
			call writemess(' The Tensor is Symmetry type, error pointting',-1)
			call error_stop
		end if
		if(A%getRank().ne.3)then
			call writemess('ERROR in Tensor%pointer, rank',-1)
			call writemess('A%getRank()='+A%getRank())
			call error_stop
		end if
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		call A%pointDim(dim)
		call ClassPointer3DFunc(A%getTotalData(),A%Data%ClassData,dim(1),dim(2),dim(3),p)
		return
	end subroutine

	subroutine Tensor4DclassPointer(A,p)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:,:,:,:)
		integer,pointer::dim(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(A%Data%getTotalBlock().ne.1)then
			call writemess(' The Tensor is Symmetry type, error pointting',-1)
			call error_stop
		end if
		if(A%getRank().ne.4)then
			call writemess('ERROR in Tensor%pointer, rank',-1)
			call writemess('A%getRank()='+A%getRank())
			call error_stop
		end if
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		call A%pointDim(dim)
		call ClassPointer4DFunc(A%getTotalData(),A%Data%ClassData,dim(1),dim(2),dim(3),dim(4),p)
		return
	end subroutine

	subroutine TensorBlock1DclassPointer(A,p,ith)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:)
		integer,intent(in)::ith
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		if(A%getFlag(ith))then
			call A%Data%ClassPointer(p,ith)
		else
			p=>null()
		end if
		return 
	end subroutine

	subroutine TensorBlock2DclassPointer(A,p,ith)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:,:)
		integer,intent(in)::ith(:)
		integer,pointer::si(:,:),ei(:,:),dim(:)
		integer::blockdim(2)
		class(*),pointer::TMP(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(.not.A%getSymmetryFlag())then
			call writemess(' The Tensor is not Symmetry type, error pointting',-1)
			call error_stop
		end if
		if(A%getRank().ne.2)then
			call writemess('ERROR in Tensor%pointer, rank',-1)
			call writemess('A%getRank()='+A%getRank())
			call error_stop
		end if
		call A%pointDim(dim)
		call check_indices_and_dim(dim,ith)
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		blockdim=A%getBlockDim(ith)
		call A%Data%pointStarti(dim(1),dim(2),si)
		call A%Data%pointEndi(dim(1),dim(2),ei)
		
		if(ei(ith(1),ith(2)).gt.0)then
			call ClassPointer1DFunc(A%Data%ClassData,si(ith(1),ith(2)),ei(ith(1),ith(2)), TMP )
			call ClassPointer2DFunc(ei(ith(1),ith(2))-si(ith(1),ith(2))+1,TMP,blockdim(1),blockdim(2),p)
		else
			p=>null()
		end if
		return 
	end subroutine

	subroutine TensorBlock3DclassPointer(A,p,ith)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:,:,:)
		integer,intent(in)::ith(:)
		integer,pointer::si(:,:,:),ei(:,:,:),dim(:)
		integer::bd(3)
		class(*),pointer::TMP(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(.not.A%getSymmetryFlag())then
			call writemess(' The Tensor is not Symmetry type, error pointting',-1)
			call error_stop
		end if
		if(A%getRank().ne.3)then
			call writemess('ERROR in Tensor%pointer, rank',-1)
			call writemess('A%getRank()='+A%getRank())
			call error_stop
		end if
		call A%pointDim(dim)
		call check_indices_and_dim(dim,ith)
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		bd=A%getBlockDim(ith)
		call A%Data%pointStarti(dim(1),dim(2),dim(3),si)
		call A%Data%pointEndi(dim(1),dim(2),dim(3),ei)

		if(ei(ith(1),ith(2),ith(3)).gt.0)then
			call ClassPointer1DFunc(A%Data%ClassData,si(ith(1),ith(2),ith(3)) , ei(ith(1),ith(2),ith(3)), TMP )
			call ClassPointer3DFunc( ei(ith(1),ith(2),ith(3)) - si(ith(1),ith(2),ith(3)) + 1 , &
								TMP,bd(1),bd(2),bd(3) , p)
		else
			p=>null()
		end if
		return 
	end subroutine

	subroutine TensorBlock4DclassPointer(A,p,ith)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:,:,:,:)
		integer,intent(in)::ith(:)
		integer,pointer::si(:,:,:,:),ei(:,:,:,:),dim(:)
		integer::bd(4)
		class(*),pointer::TMP(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(.not.A%getSymmetryFlag())then
			call writemess(' The Tensor is not Symmetry type, error pointting',-1)
			call error_stop
		end if
		if(A%getRank().ne.4)then
			call writemess('ERROR in Tensor%pointer, rank',-1)
			call writemess('A%getRank()='+A%getRank())
			call error_stop
		end if
		if(size(ith).ne.4)then
			call writemess('ERROR in Tensor%pointer, size(ith)',-1)
			call writemess('size(ith)='+size(ith))
			call error_stop
		end if
		call A%pointDim(dim)
		call check_indices_and_dim(dim,ith)
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		call A%Data%pointStarti(dim(1),dim(2),dim(3),dim(4),si)
		call A%Data%pointEndi(dim(1),dim(2),dim(3),dim(4),ei)

		if(ei(ith(1),ith(2),ith(3),ith(4)).gt.0)then
			call ClassPointer1DFunc(A%Data%ClassData,si(ith(1),ith(2),ith(3),ith(4)) , ei(ith(1),ith(2),ith(3),ith(4)), TMP )
			call ClassPointer4DFunc( ei(ith(1),ith(2),ith(3),ith(4)) - si(ith(1),ith(2),ith(3),ith(4)) + 1 , &
								TMP,bd(1),bd(2),bd(3),bd(4) , p)
		else
			p=>null()
		end if
		return 
	end subroutine


	subroutine TensorBlockclassPointer(A,p,ith)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:)
		integer,intent(in)::ith(:)
		integer,pointer::Dim(:)
		integer,pointer::si4(:,:,:,:),ei4(:,:,:,:)
		integer,pointer::si3(:,:,:),ei3(:,:,:)
		integer,pointer::si2(:,:),ei2(:,:)
		integer::index
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(.not.A%getSymmetryFlag())then
			call writemess(' The Tensor is not Symmetry type, error pointting',-1)
			call error_stop
		end if
		call A%pointDim(Dim)
		call check_indices_and_dim(dim,ith)
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		select case(size(ith))
			case(1)
				if(A%getFlag(ith(1)))then
					call A%Data%ClassPointer(p,ith(1))
				else
					p=>null()
				end if
			case(2)
				call A%Data%pointStarti(dim(1),dim(2),si2)
				call A%Data%pointEndi(dim(1),dim(2),ei2)
				if(ei2(ith(1),ith(2)).gt.0)then
					call ClassPointer1DFunc(A%Data%ClassData, si2(ith(1),ith(2)) , ei2(ith(1),ith(2)), p )
				else
					p=>null()
				end if
			case(3)
				call A%Data%pointStarti(dim(1),dim(2),dim(3),si3)
				call A%Data%pointEndi(dim(1),dim(2),dim(3),ei3)
				if(ei3(ith(1),ith(2),ith(3)).gt.0)then
					call ClassPointer1DFunc(A%Data%ClassData, si3(ith(1),ith(2),ith(3)) , ei3(ith(1),ith(2),ith(3)), p )
				else
					p=>null()
				end if
			case(4)
				call A%Data%pointStarti(dim(1),dim(2),dim(3),dim(4),si4)
				call A%Data%pointEndi(dim(1),dim(2),dim(3),dim(4),ei4)
				if(ei4(ith(1),ith(2),ith(3),ith(4)).gt.0)then
					call ClassPointer1DFunc(A%Data%ClassData, si4(ith(1),ith(2),ith(3),ith(4)) , ei4(ith(1),ith(2),ith(3),ith(4)), p )
				else
					p=>null()
				end if
			case default
				index=addressToIndes(ith,Dim)
				if(A%getFlag(index))then
					call A%Data%ClassPointer(p,index)
				else
					p=>null()
				end if
		end select
		return 
	end subroutine

	subroutine TensorDimBlock2DclassPointer(A,Adim,p,Blockdim,ith)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:,:)
		integer,intent(in)::ith(:),Adim(:),Blockdim(:)
		integer,pointer::si(:,:),ei(:,:)
		class(*),pointer::TMP(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(Blockdim(1).eq.0)then
			p=>null()
			return
		end if
		if(Blockdim(2).eq.0)then
			p=>null()
			return
		end if
		if(.not.A%getSymmetryFlag())then
			call writemess(' The Tensor is not Symmetry type, error pointting',-1)
			call error_stop
		end if
		if(size(Adim).ne.2)then
			call writemess('ERROR  dim',-1)
			call writemess('size(Adim)='+size(Adim))
			call error_stop
		end if
		if(size(Blockdim).ne.2)then
			call writemess('ERROR  Blockdim',-1)
			call writemess('size(Blockdim)='+size(Blockdim))
			call error_stop
		end if
		call check_indices_and_dim(Adim,ith,A%getTotalBlock())
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		call A%Data%pointStarti(Adim(1),Adim(2),si)
		call A%Data%pointEndi(Adim(1),Adim(2),ei)
		if(product(Blockdim).ne.(ei(ith(1),ith(2))-si(ith(1),ith(2))+1))then
			call writemess('ERROR in point to the block',-1)
			call writemess('product(Blockdim)='+product(Blockdim),-1)
			call writemess('ei(ith(1),ith(2))-si(ith(1),ith(2))+1='+(ei(ith(1),ith(2))-si(ith(1),ith(2))+1),-1)
			call writemess('si(ith(1),ith(2))='+si(ith(1),ith(2)),-1)
			call writemess('ei(ith(1),ith(2))='+ei(ith(1),ith(2)),-1)
			call writemess('ith(1)='+ith(1),-1)
			call writemess('ith(2)='+ith(2),-1)
			call error_stop
		end if
		if(ei(ith(1),ith(2)).gt.0)then
			call ClassPointer1DFunc(A%Data%ClassData, si(ith(1),ith(2)) , ei(ith(1),ith(2)), TMP )
			call ClassPointer2DFunc(ei(ith(1),ith(2))-si(ith(1),ith(2))+1,TMP,blockdim(1),blockdim(2),p)
		else
			p=>null()
		end if
		return 
	end subroutine

	subroutine TensorDimBlock3DclassPointer(A,Adim,p,Blockdim,ith)
		class(Tensor),target,intent(in)::A
		class(*),pointer,intent(inout)::p(:,:,:)
		integer,intent(in)::ith(:),Adim(:),Blockdim(:)
		integer,pointer::si(:,:,:),ei(:,:,:)
		integer::endindex,startindex
		class(*),pointer::TMP(:)
		if(.not.A%getFlag())then
			call writemess('The Tensor is empty',-1)
			call error_stop
		end if
		if(Blockdim(1).eq.0)then
			p=>null()
			return
		end if
		if(Blockdim(2).eq.0)then
			p=>null()
			return
		end if
		if(Blockdim(3).eq.0)then
			p=>null()
			return
		end if
		if(.not.A%getSymmetryFlag())then
			call writemess(' The Tensor is not Symmetry type, error pointting',-1)
			call error_stop
		end if
		if(size(Adim).ne.3)then
			call writemess('ERROR  dim',-1)
			call writemess('size(Adim)='+size(Adim))
			call error_stop
		end if
		if(size(Blockdim).ne.3)then
			call writemess('ERROR  Blockdim',-1)
			call writemess('size(Blockdim)='+size(Blockdim))
			call error_stop
		end if
		call check_indices_and_dim(Adim,ith,A%getTotalBlock())
		if(.not.A%Data%getFlag())then
			p=>null()
			return
		end if
		call A%Data%pointStarti(Adim(1),Adim(2),Adim(3),si)
		call A%Data%pointEndi(Adim(1),Adim(2),Adim(3),ei)
		startindex=si(ith(1),ith(2),ith(3))
		endindex=ei(ith(1),ith(2),ith(3))
		if(product(Blockdim).ne.(endindex-startindex+1))then
			call writemess('ERROR in point to the block',-1)
			call writemess('product(Blockdim)='+product(Blockdim),-1)
			call writemess('endindex-startindex+1='+(endindex-startindex+1),-1)
			call writemess('startindex='+startindex,-1)
			call writemess('endindex='+endindex,-1)
			call writemess('ith(1)='+ith(1),-1)
			call writemess('ith(2)='+ith(2),-1)
			call writemess('ith(3)='+ith(3),-1)
			call error_stop
		end if
		if(endindex.gt.0)then
			call ClassPointer1DFunc(A%Data%ClassData, startindex , endindex , TMP )
			call ClassPointer3DFunc(endindex-startindex+1,TMP,blockdim(1),blockdim(2),blockdim(3),p)
		else
			p=>null()
		end if
		return 
	end subroutine