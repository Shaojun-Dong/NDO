#define subTensorDimDEDATANAME subTensorDimi
#define subTensorMaxDimDEDATANAME subTensorMaxDimi
#define subTensorDeg1DDEDATANAME subTensorDeg1Di
#define subTensorMaxDeg1DDEDATANAME subTensorMaxDeg1Di
#define subTensorDeg2DDEDATANAME subTensorDeg2Di
#define subTensorMaxDeg2DDEDATANAME subTensorMaxDeg2Di
#define subTensorDeg3DDEDATANAME subTensorDeg3Di
#define subTensorMaxDeg3DDEDATANAME  subTensorMaxDeg3Di
#define DEDATANAME integer
#include "templet/reshape0.f90"
#undef subTensorDimDEDATANAME
#undef subTensorMaxDimDEDATANAME
#undef subTensorDeg1DDEDATANAME
#undef subTensorMaxDeg1DDEDATANAME
#undef subTensorDeg2DDEDATANAME
#undef subTensorMaxDeg2DDEDATANAME
#undef subTensorDeg3DDEDATANAME
#undef subTensorMaxDeg3DDEDATANAME
#undef DEDATANAME

#define subTensorDimDEDATANAME subTensorDims
#define subTensorMaxDimDEDATANAME subTensorMaxDims
#define subTensorDeg1DDEDATANAME subTensorDeg1Ds
#define subTensorMaxDeg1DDEDATANAME subTensorMaxDeg1Ds
#define subTensorDeg2DDEDATANAME subTensorDeg2Ds
#define subTensorMaxDeg2DDEDATANAME subTensorMaxDeg2Ds
#define subTensorDeg3DDEDATANAME subTensorDeg3Ds
#define subTensorMaxDeg3DDEDATANAME  subTensorMaxDeg3Ds
#define DEDATANAME real*4
#include "templet/reshape0.f90"
#undef subTensorDimDEDATANAME
#undef subTensorMaxDimDEDATANAME
#undef subTensorDeg1DDEDATANAME
#undef subTensorMaxDeg1DDEDATANAME
#undef subTensorDeg2DDEDATANAME
#undef subTensorMaxDeg2DDEDATANAME
#undef subTensorDeg3DDEDATANAME
#undef subTensorMaxDeg3DDEDATANAME
#undef DEDATANAME

#define subTensorDimDEDATANAME subTensorDimd
#define subTensorMaxDimDEDATANAME subTensorMaxDimd
#define subTensorDeg1DDEDATANAME subTensorDeg1Dd
#define subTensorMaxDeg1DDEDATANAME subTensorMaxDeg1Dd
#define subTensorDeg2DDEDATANAME subTensorDeg2Dd
#define subTensorMaxDeg2DDEDATANAME subTensorMaxDeg2Dd
#define subTensorDeg3DDEDATANAME subTensorDeg3Dd
#define subTensorMaxDeg3DDEDATANAME  subTensorMaxDeg3Dd
#define DEDATANAME real*8
#include "templet/reshape0.f90"
#undef subTensorDimDEDATANAME
#undef subTensorMaxDimDEDATANAME
#undef subTensorDeg1DDEDATANAME
#undef subTensorMaxDeg1DDEDATANAME
#undef subTensorDeg2DDEDATANAME
#undef subTensorMaxDeg2DDEDATANAME
#undef subTensorDeg3DDEDATANAME
#undef subTensorMaxDeg3DDEDATANAME
#undef DEDATANAME

#define subTensorDimDEDATANAME subTensorDimc
#define subTensorMaxDimDEDATANAME subTensorMaxDimc
#define subTensorDeg1DDEDATANAME subTensorDeg1Dc
#define subTensorMaxDeg1DDEDATANAME subTensorMaxDeg1Dc
#define subTensorDeg2DDEDATANAME subTensorDeg2Dc
#define subTensorMaxDeg2DDEDATANAME subTensorMaxDeg2Dc
#define subTensorDeg3DDEDATANAME subTensorDeg3Dc
#define subTensorMaxDeg3DDEDATANAME  subTensorMaxDeg3Dc
#define DEDATANAME complex*8
#include "templet/reshape0.f90"
#undef subTensorDimDEDATANAME
#undef subTensorMaxDimDEDATANAME
#undef subTensorDeg1DDEDATANAME
#undef subTensorMaxDeg1DDEDATANAME
#undef subTensorDeg2DDEDATANAME
#undef subTensorMaxDeg2DDEDATANAME
#undef subTensorDeg3DDEDATANAME
#undef subTensorMaxDeg3DDEDATANAME
#undef DEDATANAME

#define subTensorDimDEDATANAME subTensorDimz
#define subTensorMaxDimDEDATANAME subTensorMaxDimz
#define subTensorDeg1DDEDATANAME subTensorDeg1Dz
#define subTensorMaxDeg1DDEDATANAME subTensorMaxDeg1Dz
#define subTensorDeg2DDEDATANAME subTensorDeg2Dz
#define subTensorMaxDeg2DDEDATANAME subTensorMaxDeg2Dz
#define subTensorDeg3DDEDATANAME subTensorDeg3Dz
#define subTensorMaxDeg3DDEDATANAME  subTensorMaxDeg3Dz
#define DEDATANAME complex*16
#include "templet/reshape0.f90"
#undef subTensorDimDEDATANAME
#undef subTensorMaxDimDEDATANAME
#undef subTensorDeg1DDEDATANAME
#undef subTensorMaxDeg1DDEDATANAME
#undef subTensorDeg2DDEDATANAME
#undef subTensorMaxDeg2DDEDATANAME
#undef subTensorDeg3DDEDATANAME
#undef subTensorMaxDeg3DDEDATANAME
#undef DEDATANAME


#define subTensorDimDEDATANAME subTensorDiml
#define subTensorMaxDimDEDATANAME subTensorMaxDiml
#define subTensorDeg1DDEDATANAME subTensorDeg1Dl
#define subTensorMaxDeg1DDEDATANAME subTensorMaxDeg1Dl
#define subTensorDeg2DDEDATANAME subTensorDeg2Dl
#define subTensorMaxDeg2DDEDATANAME subTensorMaxDeg2Dl
#define subTensorDeg3DDEDATANAME subTensorDeg3Dl
#define subTensorMaxDeg3DDEDATANAME  subTensorMaxDeg3Dl
#define DEDATANAME logical
#include "templet/reshape0.f90"
#undef subTensorDimDEDATANAME
#undef subTensorMaxDimDEDATANAME
#undef subTensorDeg1DDEDATANAME
#undef subTensorMaxDeg1DDEDATANAME
#undef subTensorDeg2DDEDATANAME
#undef subTensorMaxDeg2DDEDATANAME
#undef subTensorDeg3DDEDATANAME
#undef subTensorMaxDeg3DDEDATANAME
#undef DEDATANAME

#define subTensorDimDEDATANAME subTensorDima
#define subTensorMaxDimDEDATANAME subTensorMaxDima
#define subTensorDeg1DDEDATANAME subTensorDeg1Da
#define subTensorMaxDeg1DDEDATANAME subTensorMaxDeg1Da
#define subTensorDeg2DDEDATANAME subTensorDeg2Da
#define subTensorMaxDeg2DDEDATANAME subTensorMaxDeg2Da
#define subTensorDeg3DDEDATANAME subTensorDeg3Da
#define subTensorMaxDeg3DDEDATANAME  subTensorMaxDeg3Da
#define DEDATANAME character(len=characterlen)
#include "templet/reshape0.f90"
#undef subTensorDimDEDATANAME
#undef subTensorMaxDimDEDATANAME
#undef subTensorDeg1DDEDATANAME
#undef subTensorMaxDeg1DDEDATANAME
#undef subTensorDeg2DDEDATANAME
#undef subTensorMaxDeg2DDEDATANAME
#undef subTensorDeg3DDEDATANAME
#undef subTensorMaxDeg3DDEDATANAME
#undef DEDATANAME

	subroutine subTensorDimSubroutine(A,DimMin,DimMax,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DimMin(:),DimMax(:)
		select case(A%getType())
			case(1)
				call subTensorDimi(A,DimMin,DimMax,Res)
			case(2)
				call subTensorDims(A,DimMin,DimMax,Res)
			case(3)
				call subTensorDimd(A,DimMin,DimMax,Res)
			case(4)
				call subTensorDimc(A,DimMin,DimMax,Res)
			case(5)
				call subTensorDimz(A,DimMin,DimMax,Res)
			case(6)
				call subTensorDiml(A,DimMin,DimMax,Res)
			case(7)
				call subTensorDima(A,DimMin,DimMax,Res)
		end select
		return
	end subroutine

	subroutine subTensorMaxDimSubroutine(A,DimMax,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DimMax(:)
		select case(A%getType())
			case(1)
				call subTensorMaxDimi(A,DimMax,Res)
			case(2)
				call subTensorMaxDims(A,DimMax,Res)
			case(3)
				call subTensorMaxDimd(A,DimMax,Res)
			case(4)
				call subTensorMaxDimc(A,DimMax,Res)
			case(5)
				call subTensorMaxDimz(A,DimMax,Res)
			case(6)
				call subTensorMaxDiml(A,DimMax,Res)
			case(7)
				call subTensorMaxDima(A,DimMax,Res)
		end select
		return
	end subroutine

	subroutine subTensorDeg1DSubroutine(A,DegMinMax,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DegMinMax(:,:)
		select case(A%getType())
			case(1)
				call subTensorDeg1Di(A,DegMinMax,Res)
			case(2)
				call subTensorDeg1Ds(A,DegMinMax,Res)
			case(3)
				call subTensorDeg1Dd(A,DegMinMax,Res)
			case(4)
				call subTensorDeg1Dc(A,DegMinMax,Res)
			case(5)
				call subTensorDeg1Dz(A,DegMinMax,Res)
			case(6)
				call subTensorDeg1Dl(A,DegMinMax,Res)
			case(7)
				call subTensorDeg1Da(A,DegMinMax,Res)
		end select
		return
	end subroutine

	subroutine subTensorMaxDeg1DSubroutine(A,DegMax,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DegMax(:)
		select case(A%getType())
			case(1)
				call subTensorMaxDeg1Di(A,DegMax,Res)
			case(2)
				call subTensorMaxDeg1Ds(A,DegMax,Res)
			case(3)
				call subTensorMaxDeg1Dd(A,DegMax,Res)
			case(4)
				call subTensorMaxDeg1Dc(A,DegMax,Res)
			case(5)
				call subTensorMaxDeg1Dz(A,DegMax,Res)
			case(6)
				call subTensorMaxDeg1Dl(A,DegMax,Res)
			case(7)
				call subTensorMaxDeg1Da(A,DegMax,Res)
		end select
		return
	end subroutine

	subroutine subTensorDeg2DSubroutine(A,DegMinMax1,DegMinMax2,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DegMinMax1(:,:),DegMinMax2(:,:)
		select case(A%getType())
			case(1)
				call subTensorDeg2Di(A,DegMinMax1,DegMinMax2,Res)
			case(2)
				call subTensorDeg2Ds(A,DegMinMax1,DegMinMax2,Res)
			case(3)
				call subTensorDeg2Dd(A,DegMinMax1,DegMinMax2,Res)
			case(4)
				call subTensorDeg2Dc(A,DegMinMax1,DegMinMax2,Res)
			case(5)
				call subTensorDeg2Dz(A,DegMinMax1,DegMinMax2,Res)
			case(6)
				call subTensorDeg2Dl(A,DegMinMax1,DegMinMax2,Res)
			case(7)
				call subTensorDeg2Da(A,DegMinMax1,DegMinMax2,Res)
		end select
		return
	end subroutine

	subroutine subTensorMaxDeg2DSubroutine(A,DegMax1,DegMax2,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DegMax1(:),DegMax2(:)
		select case(A%getType())
			case(1)
				call subTensorMaxDeg2Di(A,DegMax1,DegMax2,Res)
			case(2)
				call subTensorMaxDeg2Ds(A,DegMax1,DegMax2,Res)
			case(3)
				call subTensorMaxDeg2Dd(A,DegMax1,DegMax2,Res)
			case(4)
				call subTensorMaxDeg2Dc(A,DegMax1,DegMax2,Res)
			case(5)
				call subTensorMaxDeg2Dz(A,DegMax1,DegMax2,Res)
			case(6)
				call subTensorMaxDeg2Dl(A,DegMax1,DegMax2,Res)
			case(7)
				call subTensorMaxDeg2Da(A,DegMax1,DegMax2,Res)
		end select
		return
	end subroutine

	subroutine subTensorDeg3DSubroutine(A,DegMinMax1,DegMinMax2,DegMinMax3,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DegMinMax1(:,:),DegMinMax2(:,:),DegMinMax3(:,:)
		select case(A%getType())
			case(1)
				call subTensorDeg3Di(A,DegMinMax1,DegMinMax2,DegMinMax3,Res)
			case(2)
				call subTensorDeg3Ds(A,DegMinMax1,DegMinMax2,DegMinMax3,Res)
			case(3)
				call subTensorDeg3Dd(A,DegMinMax1,DegMinMax2,DegMinMax3,Res)
			case(4)
				call subTensorDeg3Dc(A,DegMinMax1,DegMinMax2,DegMinMax3,Res)
			case(5)
				call subTensorDeg3Dz(A,DegMinMax1,DegMinMax2,DegMinMax3,Res)
			case(6)
				call subTensorDeg3Dl(A,DegMinMax1,DegMinMax2,DegMinMax3,Res)
			case(7)
				call subTensorDeg3Da(A,DegMinMax1,DegMinMax2,DegMinMax3,Res)
		end select
		return
	end subroutine

	subroutine subTensorMaxDeg3DSubroutine(A,DegMax1,DegMax2,DegMax3,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DegMax1(:),DegMax2(:),DegMax3(:)
		select case(A%getType())
			case(1)
				call subTensorMaxDeg3Di(A,DegMax1,DegMax2,DegMax3,Res)
			case(2)
				call subTensorMaxDeg3Ds(A,DegMax1,DegMax2,DegMax3,Res)
			case(3)
				call subTensorMaxDeg3Dd(A,DegMax1,DegMax2,DegMax3,Res)
			case(4)
				call subTensorMaxDeg3Dc(A,DegMax1,DegMax2,DegMax3,Res)
			case(5)
				call subTensorMaxDeg3Dz(A,DegMax1,DegMax2,DegMax3,Res)
			case(6)
				call subTensorMaxDeg3Dl(A,DegMax1,DegMax2,DegMax3,Res)
			case(7)
				call subTensorMaxDeg3Da(A,DegMax1,DegMax2,DegMax3,Res)
		end select
		return
	end subroutine

	subroutine subTensorCutDeg(A,ith,DegMax,Res)
		class(Tensor),intent(in)::A
		type(Tensor),intent(inout)::Res
		integer,intent(in)::DegMax(:),ith
		integer,pointer::deg1(:),deg2(:)
		integer::rank
		if(.not.A%getSymmetryFlag())then
			call writemess('ERROR in subTensorDim. The input Tensor is not of Symmery',-1)
			call error_stop
		end if
		rank=A%getRank()
		select case(rank)
			case(1)
				call subTensorMaxDeg1DSubroutine(A,DegMax,Res)
			case(2)
				if(ith.eq.1)then
					call A%pointDeg(Deg1,2)
					call subTensorMaxDeg2DSubroutine(A,DegMax,Deg1,Res)
				else if(ith.eq.2)then
					call A%pointDeg(Deg1,1)
					call subTensorMaxDeg2DSubroutine(A,Deg1,DegMax,Res)
				else
					call writemess('ERROR in subTensorDim. ith='+ith+' ,rank='+rank,-1)
					call error_stop
				end if
			case(3)
				if(ith.eq.1)then
					call A%pointDeg(Deg1,2)
					call A%pointDeg(Deg2,3)
					call subTensorMaxDeg3DSubroutine(A,DegMax,Deg1,Deg2,Res)
				else if(ith.eq.2)then
					call A%pointDeg(Deg1,1)
					call A%pointDeg(Deg2,3)
					call subTensorMaxDeg3DSubroutine(A,Deg1,DegMax,Deg2,Res)
				else if(ith.eq.3)then
					call A%pointDeg(Deg1,1)
					call A%pointDeg(Deg2,2)
					call subTensorMaxDeg3DSubroutine(A,Deg1,Deg2,DegMax,Res)
				else
					call writemess('ERROR in subTensorDim. ith='+ith+' ,rank='+rank,-1)
					call error_stop
				end if
			case default
				call writemess('ERROR in subTensorDim. rank='+rank,-1)
				call error_stop
		end select
		return
	end subroutine


	function check_if_diag(T)Result(Res)
		logical::Res
		type(Tensor),intent(in)::T
		integer::i,j,ii,jj
		integer,pointer::dim(:)
		if(T%getRank().ne.2)then
			call writemess('ERROR, the input Tensor is not amatrix',-1)
			call T%diminfo(.true.)
			call error_Stop
		end if
		call T%pointDim(Dim)
		ii=0
		jj=0
		Res=.true.
		do i=1,dim(1)
			do j=1,dim(2)
				if(if_symmetry_rule(T%Dimension,[i,j]))then
					if(i.lt.ii)then
						Res=.false.
						return
					end if
					if(j.lt.jj)then
						Res=.false.
						return
					end if
					ii=i
					jj=j
				end if
			end do
		end do
		return
	end function

	subroutine reOrderToDiag(T,outNewOrder,Flag)
		class(Tensor),intent(inout)::T
		integer,intent(inout)::outNewOrder(:)
		logical,intent(inout)::Flag
		integer,pointer::si(:,:),ei(:,:)
		integer,pointer::starti(:),Endi(:)
		integer,pointer::oldsi(:,:),oldei(:,:),NewOrder(:)
		integer::i,j,m,n,ii
		real*4,pointer::QN(:),OldQN(:)
		integer,pointer::deg(:),OldDeg(:),rule(:)
		Flag=check_if_diag(T)
		if(Flag) return
		if(T%getRank().ne.2)then
			call writemess('The input should be a matrix in reOrderToDiag ')
			call error_stop
		end if
		m=T%dim(1)
		n=T%dim(2)
		if(size(outNewOrder).ne.n)then
			call writemess('error,outNewOrder= '+size(outNewOrder),-1)
			call error_stop
		end if
		call WorkingMemory%check()
		call WorkingMemory%allocate(1,m*n*2+n+n)
		call WorkingMemory%allocate(2,n)
		call WorkingMemory%get_memory(oldsi,m,n)
		call WorkingMemory%get_memory(oldei,m,n)
		call WorkingMemory%get_memory(NewOrder,n)
		ii=0
		do i=1,m
			do j=1,n
				if(if_symmetry_rule(T%dimension,[i,j]))then
					ii=ii+1
					NewOrder(ii)=j
					outNewOrder(j)=ii
					Flag=.false.
					exit
				end if
			end do
		end do
		do i=1,n
			if(.not.if_In_the_array(i,NewOrder(1:ii),ii))then
				ii=ii+1
				NewOrder(ii)=i
				outNewOrder(i)=ii
			end if
		end do



		call T%Data%pointStarti(Starti)
		call T%Data%pointEndi(Endi)
		si(1:m,1:n)=>Starti
		ei(1:m,1:n)=>endi

		oldsi=si
		oldei=ei
		do j=1,n
			do i=1,m
				si(i,j)=oldsi(i,NewOrder(j))
				ei(i,j)=oldei(i,NewOrder(j))
			end do
		end do

		call WorkingMemory%get_memory(OldQN,n)
		call WorkingMemory%get_memory(OldDeg,n)
		call T%pointQN(QN,2)
		call T%pointDeg(Deg,2)
		OldQN=QN
		OldDeg=Deg
		do i=1,n
			QN(i)=OldQN(NewOrder(i))
			deg(i)=OldDeg(NewOrder(i))
		end do

		call WorkingMemory%free()
		return
	end subroutine

	subroutine reOrderTensor(T,NewOrder,Flag)
		class(Tensor),intent(inout)::T
		integer,intent(in)::NewOrder(:)
		logical,intent(in)::Flag
		integer,pointer::si(:,:),ei(:,:)
		integer,pointer::starti(:),Endi(:)
		integer,pointer::oldsi(:,:),oldei(:,:)
		integer::i,j,m,n,ii
		real*4,pointer::QN(:),OldQN(:)
		integer,pointer::deg(:),OldDeg(:),rule(:)
		if(Flag)return
		if(T%getRank().ne.2)then
			call writemess('The input should be a matrix in reOrderTensor ')
			call error_stop
		end if
		m=T%dim(1)
		n=T%dim(2)
		if(size(NewOrder).ne.n)then
			call writemess('error,outNewOrder= '+size(NewOrder),-1)
			call error_stop
		end if
		call WorkingMemory%check()
		call WorkingMemory%allocate(1,m*n*2+n)
		call WorkingMemory%allocate(2,n)
		call WorkingMemory%get_memory(oldsi,m,n)
		call WorkingMemory%get_memory(oldei,m,n)


		call T%Data%pointStarti(Starti)
		call T%Data%pointEndi(Endi)
		si(1:m,1:n)=>Starti
		ei(1:m,1:n)=>endi

		oldsi=si
		oldei=ei
		do j=1,n
			do i=1,m
				si(i,j)=oldsi(i,NewOrder(j))
				ei(i,j)=oldei(i,NewOrder(j))
			end do
		end do

		call WorkingMemory%get_memory(OldQN,n)
		call WorkingMemory%get_memory(OldDeg,n)
		call T%pointQN(QN,2)
		call T%pointDeg(Deg,2)
		OldQN=QN
		OldDeg=Deg
		do i=1,n
			QN(i)=OldQN(NewOrder(i))
			deg(i)=OldDeg(NewOrder(i))
		end do

		call WorkingMemory%free()
		return
	end subroutine